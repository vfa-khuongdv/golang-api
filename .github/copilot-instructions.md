# Golang CMS - Copilot Instructions

## Repository Overview

This is a Go-based CMS REST API with user authentication, MFA (TOTP), JWT tokens, and refresh tokens. The project implements clean architecture with handlers → services → repositories → models layers. All code uses testify for testing and the apperror package for standardized error handling.

**Key Technologies:** Go 1.21+, Gin framework, GORM, MySQL, JWT, Testify, Docker

## Project Layout & Architecture

```
golang-cms/
├── cmd/
│   ├── server/main.go          # Application entry point
│   └── seeder/seeder.go        # Database seeding utility
├── internal/
│   ├── handlers/               # HTTP handlers (Gin)
│   ├── services/               # Business logic layer
│   ├── repositories/           # Data access layer (GORM)
│   ├── models/                 # Domain models
│   ├── middlewares/            # HTTP middlewares (auth, CORS, logging)
│   ├── configs/                # Configuration and environment loading
│   ├── constants/              # Application constants
│   ├── routes/                 # Route definitions
│   ├── utils/                  # Utility functions
│   └── database/               # Migrations and seeders
├── pkg/                        # Reusable packages
│   ├── apperror/               # Error codes and error types
│   ├── logger/                 # Logging utility
│   ├── mailer/                 # Email/SMTP service
│   └── migrator/               # Database migration runner
├── tests/mocks/                # Mock implementations for testing
├── DEVELOPMENT.md              # Detailed development guidelines
├── TESTING.md                  # Testing standards and patterns
├── Dockerfile                  # Docker container configuration
├── docker-compose.yml          # Multi-container orchestration
├── go.mod                      # Go module definition
├── Makefile                    # Build and run commands
└── README.md                   # Project documentation
```

## Build & Validation Commands

**Prerequisites:** Go 1.21+, MySQL 8.0+, Make

**Bootstrap & Setup:**
```bash
# Install dependencies
go mod download

# Setup database (requires running MySQL container)
docker-compose up -d mysql

# Run migrations
go run cmd/seeder/seeder.go
```

**Build:**
```bash
# Build server binary
make build

# Output: ./tmp/server executable
```

**Tests & Validation:**
```bash
# Run all tests with coverage
go test ./... -v --cover

# All tests must pass. Expected: 11 packages passing with 62%-100% coverage
# - handlers: 98.6%
# - repositories: 90.5%
# - services: 62.1%
# - utils: 84.8%
# - pkg/apperror: 100%
# - pkg/logger: 83.3%
# - pkg/mailer: 100%
# - pkg/migrator: 96.0%

# Run specific package tests
go test ./internal/handlers -v

# Run specific test
go test ./internal/handlers -run TestUserHandler_CreateUser -v
```

**Linting:**
```bash
# Go format check
go fmt ./...

# Go vet analysis
go vet ./...

# Run all linting (requires golangci-lint)
golangci-lint run ./...
```

**Running the Application:**
```bash
# Start database container
docker-compose up -d mysql

# Run migrations and seeding
go run cmd/seeder/seeder.go

# Start server (default port 8080)
go run cmd/server/main.go

# Server runs on http://localhost:8080
```

## Key Architectural Patterns

**Layer Responsibilities:**
- **Handlers:** Accept HTTP requests, validate input format, call services, return HTTP responses
- **Services:** Implement business logic, orchestrate repositories, validate business rules, return errors using apperror
- **Repositories:** GORM database operations, return entities or errors
- **Models:** Domain objects with validation methods, GORM tags, JSON serialization tags

**Dependencies & Interfaces:**
- All layers depend on abstractions (interfaces), never concrete implementations
- Services receive repositories via constructor (dependency injection)
- Handlers receive services via constructor
- Test mocks use testify/mock package

**Error Handling:**
- All errors use `github.com/vfa-khuongdv/golang-cms/pkg/apperror` package
- Validation errors: `apperror.NewValidationError()`
- Not found errors: `apperror.NewNotFoundError()`
- Conflict errors: `apperror.NewConflictError()`
- Server errors: wrapped with context
- HTTP mapping: 400 (validation), 401 (auth), 403 (forbidden), 404 (not found), 409 (conflict), 500 (server error)

**Authentication:**
- JWT tokens generated by JWTService
- Tokens expire (configurable, typically 15 minutes)
- Refresh tokens stored in database via RefreshTokenRepository
- MFA (TOTP) implemented with TotpService and MfaRepository
- AuthMiddleware validates JWT on protected routes

## Testing Standards

**All tests must:**
- Use testify/assert and testify/require packages
- Group related tests using `t.Run()` with descriptive names
- Follow AAA pattern: Arrange (setup), Act (execute), Assert (verify)
- Mock external dependencies (repositories, services)
- Include both success and failure test cases
- Never use hardcoded values (use named constants)

**Test File Structure:**
```go
func TestServiceName_MethodName(t *testing.T) {
    t.Run("successful case", func(t *testing.T) {
        // Arrange: setup mocks and fixtures
        mockRepo := new(MockRepository)
        mockRepo.On("Method", mock.Anything).Return(expectedValue, nil)
        
        // Act: call the function
        result, err := svc.MethodName(context.Background(), input)
        
        // Assert: verify behavior
        require.NoError(t, err)
        assert.Equal(t, expectedValue, result)
        mockRepo.AssertExpectations(t)
    })
    
    t.Run("error case", func(t *testing.T) {
        // ...
    })
}
```

**Database Testing:**
- Use in-memory SQLite for repository tests
- Create test fixtures before each test
- Clean up database state after each test
- Never use real MySQL database in unit tests

## Important Implementation Rules

**Always DO:**
- Use dependency injection for testability
- Handle all errors explicitly
- Use apperror package for all application errors
- Write tests immediately after writing code
- Update DEVELOPMENT.md and TESTING.md if adding new patterns
- Verify all tests pass before committing: `go test ./... -v --cover`
- Use meaningful variable and function names
- Add comments for "why", not "what"

**Never DO:**
- Ignore errors silently
- Use global variables
- Mix concerns between layers (business logic in handlers)
- Hardcode configuration values
- Create test files without grouped subtests
- Use internal packages outside internal/
- Bypass AuthMiddleware on protected endpoints
- Store passwords in plain text
- Log sensitive information

## Continuous Integration Checks

When making changes, verify:
1. **All tests pass:** `go test ./... -v --cover`
2. **No formatting issues:** `go fmt ./...`
3. **No vet warnings:** `go vet ./...`
4. **No lint errors:** `golangci-lint run ./...` (if installed)
5. **Server builds:** `go build -o /tmp/server ./cmd/server/main.go`
6. **Database migrations work:** `go run cmd/seeder/seeder.go`

## Configuration & Environment

Environment variables (from `.env` file, see `internal/configs/env.go`):
- `DB_HOST`, `DB_PORT`, `DB_USER`, `DB_PASSWORD`, `DB_NAME` - Database connection
- `JWT_SECRET` - Secret key for JWT token signing
- `JWT_EXPIRY` - Token expiration in seconds (default: 900)
- `REFRESH_TOKEN_EXPIRY` - Refresh token expiration in seconds (default: 604800)
- `SMTP_HOST`, `SMTP_PORT`, `SMTP_USER`, `SMTP_PASSWORD` - Email configuration
- `APP_PORT` - Server port (default: 8080)

For local development, see `.env.example` in root directory.

## When Adding New Features

1. **Start with the model:** Define domain model with validation
2. **Add repository layer:** Define interface, implement GORM operations, write tests
3. **Add service layer:** Implement business logic, write tests with mocked repositories
4. **Add handler layer:** Accept requests, validate, call service, return responses, write tests
5. **Add routes:** Register handler in internal/routes/routes.go
6. **Run all tests:** `go test ./... -v --cover` must pass
7. **Update documentation:** If introducing new patterns, update DEVELOPMENT.md and TESTING.md

## Debugging Tips

- Enable verbose logging by checking logger.go implementation
- Use `go test -run TestName -v` to run specific tests
- Use `go test -race` to detect race conditions
- Check `internal/configs/database_test.go` for test database setup patterns
- Check `tests/mocks/` for mock implementation examples
- View swagger documentation at `/docs` endpoint when server is running

Trust these instructions. Only search the codebase if you find inconsistencies between these instructions and actual implementation.
